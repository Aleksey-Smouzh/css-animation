* {
    margin: 0; /*сввойство margion создает пространство вокруг элемента*/
    padding: 0; /* свойство padding или внутренний отступ -позволяет оттолкнуть контент от границы родительского элемента Самая прикольная фишка,
        которую можно реализовать при помощи padding — адаптивные картинки,
        которые при изменении ширины экрана изменяют свой размер,
        но не деформируются*/
    box-sizing: border-box; /*при помощи этого свойсва можно изменить то как браузер будет рассчитывать размеры элемента  border - box значение width and height явлчються финальнымиразмерами элемента. финальная ширина = штрина. В самом начале работы «сбросить» стандартное значение,
        заменив его на предсказуемое box-sizing.
        Для «сброса» можно использовать универсальный селектор. Напиши в самом начале файла со стилями Теперь все размеры элементов будут равны тем значениям,
            что заданы в свойствах width и height.*/
}

.container {
    display: flex; /* элемент становиться флекс-контейнером ведет себя как блочный элемент, а вложенный элемент становиться флекс-элементами*/
    justify-content: center; /*свойство позволяет выравнивать флекс-элемент внутри флекс-контейнера по основной оси в данном случае по центру (по центру родителя)*/
    align-items: center; /* свойство выравнивает элемент внутри контейнера по поеречной оси в данном случае элементы выстраиваются по центру поперечной оси*/
    min-height: 100vh; /* помимо фиксации высоты мы можем задать минимальную высоту элемента - в этом случае элемент сможет растягиваться на большую высоту, если того требует контент, размещенный внутри, но никогда не сожмется по высоте меньше чем указано в свойсве min-height */
    background: #042104;
    filter: hue-rotate(70deg); /* filter  свойство  которое применяет графические эффекты такие как размытие , изменение контрастности  или отенка, к элемену. HUE-ROTATE()-> функция, котррая изменяет оттенок элементов, поворачивая их цветовой круг на заданный угол. 70deg -> вращение на 70 градусов по часовой стрелке*/
}

.loader {
    position: relative; /* position свойтсво задает способ позиционирования элементов в докуменете Элемент позиционируется так же,
        как и статичный,
        но его отображение может быть смещено относительно своего начального положения при помощи свойств left,
        right,
        top,
        bottom или inset*/
    transform: rotate(calc(45deg * var(--j)));
/* transform:
        Свойство CSS, которое применяется для преобразования элементов, таких как поворот, масштабирование, сдвиг или наклон.
        В данном случае используется функция rotate() для поворота элемента.
    rotate(angle):
            Функция преобразования, которая вращает элемент на указанный угол вокруг его центра. Угол задается в градусах (deg), радианах (rad), градах (grad) или оборотах (turn). 
    calc():
            Функция CSS, которая позволяет выполнять вычисления для значения свойства. В данном случае используется для вычисления угла поворота на основе переменной.
    45deg:
            Константное значение угла в 45 градусов.
            Это базовый угол, на который будет умножаться значение переменной --i.
  var(--i):
            Функция CSS, которая используется для обращения к значению пользовательской переменной. Переменная --i должна быть определена в другом месте CSS или в элементе для которого применяется transform.*/
}

.loader span {
    position: absolute;
    transform: rotate(calc(18deg * var(--i)));

}


.loader span:before {
    content: ""; /*Когда задано свойство content,
        то элемент заменяется на значение этого свойства. В качестве значения могут быть переданы различные типы: изображение, градиент или текст.*/
    position: absolute;
    width: 15px;
    height: 15px;
    border: 2px solid #00ff0a;
    border-radius: 2px;
    animation: animate 5s linear infinite; /*используется для задания анимации на элементе 
    animation:
            Свойство CSS, которое объединяет в себе несколько под-свойств, связанных с анимацией. В данном случае используется для задания последовательности анимации на элементе.
    animate:
            Это название анимации, которая должна быть определена с помощью ключевых кадров (@keyframes). Например, если анимация называется animate, нужно определить ключевые кадры с таким именем.
    5s (продолжительность):
            Задает продолжительность одного цикла анимации. В данном случае анимация будет длиться 5 секунд.
    linear (функция временной интерполяции):
            Задает, как скорость анимации изменяется с течением времени. linear означает, что анимация будет выполняться с постоянной скоростью от начала до конца.
    infinite (количество повторений):
            Задает, сколько раз анимация будет повторяться. infinite означает, что анимация будет повторяться бесконечно.
            */
    animation-delay: calc(-0.5s * var(--i)); /*используется для задания задержки перед началом анимации
    animation-delay:
            Это свойство CSS, которое определяет время задержки перед началом выполнения анимации. Значение может быть положительным или отрицательным. Положительное значение задерживает начало анимации, отрицательное значение позволяет анимации начать в состоянии, как будто она уже выполняется на заданное время.
        calc(-0.5s * var(--i)):
        
                calc() — это CSS функция, которая позволяет выполнять вычисления с разными единицами (пиксели, проценты, секунды и т.д.) непосредственно в CSS. -0.5s — это базовое значение времени, которое будет умножаться. var(--i) — это переменная CSS, которая подставляется в выражение. Значение переменной --i задается заранее и может изменяться в зависимости от элемента.
    */
}
/* nth-child(even)выбирает каждый второй элемент среди элементов начиная с первого.
:nth-child(odd): выбирает нечетные элементы (1-й, 3-й, 5-й и т.д.).
:nth-child(n): выбирает каждый элемент.
:nth-child(3n): выбирает каждый третий элемент.
:nth-child(3n+1): выбирает каждый третий элемент,
*/
.loader:nth-child(even) span::before {
    background: #00ff0a;
}
/*Директива @keyframes используется для определения ключевых кадров анимации в CSS. Она позволяет создать сложные анимации,
задавая промежуточные состояния элементов на протяжении времени выполнения анимации. В данном примере анимации animate задаются три ключевых состояния: в начале,
в середине и в конце анимации.
Подробное объяснение: 
@keyframes animate: Определяет анимацию с именем animate. 
Ключевые кадры: 0%: Начальное состояние анимации.
transform: translateX(250px) scale(4);
translateX(250px) — элемент смещен вправо на 250 пикселей. scale(4) — элемент увеличен в 4 раза. 
opacity: 0;
— элемент полностью прозрачный. 
50%: Промежуточное состояние анимации.
opacity: 1; — элемент полностью видимый. 
100%: Конечное состояние анимации.
transform: translateX(-10px) scale(0);
translateX(-10px) — элемент смещен влево на 10 пикселей.
 scale(0) — элемент уменьшен до нуля,
т.е. исчезает.
*/
@keyframes animate {
    0% {
        transform: translateX(250px) scale(4);
        opacity: 0;
    }

    50% {
        opacity: 1;
    }

    100% {
        transform: translateX(-10px) scale(0);
    }
}